/ *
 Copyright (C) Federico Zivolo 2017
 Distribuido bajo la licencia MIT (los términos de la licencia se encuentran en http://opensource.org/licenses/MIT).
 * / for (var e = 'undefined'! = typeof window && 'undefined'! = typeof document, t = ['Edge', 'Trident', 'Firefox'], o = 0, n = 0; n <t. length; n + = 1) if (e && 0 <= navigator.userAgent.indexOf (t [n])) {o = 1; break} function i (e) {var t =! 1; return function () {t || (t =! 0, window.Promise.resolve (). then (function () {t =! 1, e ()}))}} function r (e) {var t =! 1; return function () { t || (t =! 0, setTimeout (function () {t =! 1, e ()}, o))}} var p = e && window.Promise, s = p? i: r; function d (e) {return e && '[object Function]' === {}. toString.call (e)} function a (e, t) {if (1! == e.nodeType) return []; var o = getComputedStyle (e , nulo); return t? o [t]: o} function l (e) {return'HTML '=== e.nodeName? e: e.parentNode || e.host} function f (e) {if ( ! e) return document.body; switch (e.nodeName) {case'HTML ': case'BODY': return e.ownerDocument.body; case '#documento ': return e.body;} var t = a (e), o = t.overflow, i = t.overflowX, n = t.overflowY; return /(auto|scroll)/.test(o+n + i)? e: f (l (e))} función m (e) {var t = e && e.offsetParent, o = t && t.nodeName; return o && 'BODY'! == o && 'HTML'! == o? -1! == ['TD', 'TABLE']. IndexOf (t.nodeName) && 'static' === a (t, 'position')? M (t): t: e? E.ownerDocument. documentElement: document.documentElement} función h (e) {var t = e.nodeName; return'BODY '! == t && (' HTML '=== t || m (e.firstElementChild) === e)} función c (e) {return null === e.parentNode? e: c (e.parentNode)} function u (e, t) {if (! e ||! e.nodeType ||! t ||! t. nodeType) return document.documentElement; var o = e.compareDocumentPosition (t) & Node.DOCUMENT_POSITION_FOLLOWING, i = o? e: t, n = o? t: e, r = document.createRange (); r.setStart (i, 0), r.setEnd (n, 0); var p = r.commonAncestorContainer; if (e! == p && t! == p || i.contains (n)) return h (p)? p: m (p); var s = c (e); return s.host?u ( s.host, t): u (e, c (t) .host)} función g (e) {var t = 1 <argumentos.longitud && argumentos [1]! == void 0? argumentos [1]: 'arriba' , o = 'top' === t? 'scrollTop': 'scrollLeft', i = e.nodeName; if ('BODY' === i || 'HTML' === i) {var n = e. ownerDocument.documentElement, r = e.ownerDocument.scrollingElement || n; return r [o]} return e [o]} función b (e, t) {var o = 2 <argumentos.length && void 0! == argumentos [2 ] && argumentos [2], i = g (t, 'arriba'), n = g (t, 'izquierda'), r = o? -1: 1; return e.top + = i * r, e.bottom + = i * r, e.left + = n * r, e.right + = n * r, e} function w (e, t) {var o = 'x' === t? 'Left': 'Top', i = 'Izquierda' == o? 'Derecha': 'Abajo'; return parseFloat (e ['borde' + o + 'Ancho'], 10) + parseFloat (e ['border '+ i +' Width '], 10)} var y, E = function () {return void 0 == y && (y = -1! == navigator.appVersion.indexOf (' MSIE 10 ')), y} ; función v (e, t, o, i) {return Math.max (t ['desplazamiento' + e], t ['desplazamiento' + e], o ['cliente' + e], o ['desplazamiento' ' + e], o ['scroll' + e], E ()? o ['offset' + e] + i ['margin' + ('Height' === e? 'Top': 'Left')] + i ['margin' + ('Height' === e? 'Bottom': 'Right')]: 0)} function x () {var e = document.body, t = document.documentElement, o = E () && getComputedStyle (t); return {altura: v ('Altura', e, t, o), ancho: v ('Ancho', e, t, o)}} var O = función (e, t) { if (! (e instanceof t)) throw new TypeError ('No se puede llamar a una clase como función')}, L = function () {function e (e, t) {for (var o, n = 0; n < t.length; n ++) o = t [n], o.enumerable = o.enumerable ||! 1, o.configurable =! 0, 'value'in o && (o.writable =! 0), Object.defineProperty (e, o.key, o)} función de retorno (t, o, i) {return o && e (t.prototype, o), i && e (t, i), t}} (), S = function (e, t, o) {return t in e? Object.defineProperty (e, t, {valor: o, enumerable:! 0, configurable:! 0, escribible: ! 0}): e [t] = o, e}, T = Object.assign || function (e) {for (var t, o = 1; o <argumentos.length; o ++) for (var i in t = argumentos [o], t) Object.prototype.hasOwnProperty.call (t, i) && (e [i] = t [i]); return e}; función D (e) {return T ({}, e , {derecha: e.izquierda + e.width, abajo: e.top + e.height})} función N (e) {var t = {}; try {if (E ()) {t = e.getBoundingClientRect (); var o = g (e, 'arriba'), i = g (e, 'izquierda'); t.top + = o, t.left + = i, t.bottom + = o, t.right + = i} else t = e.getBoundingClientRect ()} catch (t) {} var n = {left: t.left, top: t.top, width: t.right-t.left, height: t.bottom-t.top }, r = 'HTML' === e.nodeName? x (): {}, p = r.width || e.clientWidth || n.derecha-n. izquierda, s = r.altura || e.clientHeight || n.bottom-n.top, d = e.offsetWidth-p, l = e.offsetHeight-s; if (d || l) { var f = a (e); d- = w (f, 'x'), l- = w (f, 'y'), n.width- = d, n.height- = l} return D (n )} función C (e, t) {var o = E (), i = 'HTML' === t.nodeName, n = N (e), r = N (t), p = f (e), s = a (t), d = parseFloat (s.borderTopWidth, 10), l = parseFloat (s.borderLeftWidth, 10), m = D ({top: n.top-r.top-d, left: n. left-r.left-l, width: n.width, height: n.height}); if (m.marginTop = 0, m.marginLeft = 0,! o && i) {var h = parseFloat (s.marginTop, 10 ), c = parseFloat (s.marginLeft, 10); m.top- = dh, m.bottom- = dh, m.left- = lc, m.right- = lc, m.marginTop = h, m.marginLeft = c} return (o? t.contains (p): t === p && 'BODY'! == p.nodeName) && (m = b (m, t)), m} función k (e) {var t = Math.max, o = e.ownerDocument.documentElement, i = C (e, o), n = t (o.clientWidth, window.innerWidth || 0), r = t (o.clientHeight, window.innerHeight || 0), p = g (o),s = g (o, 'left'), d = {top: pi.top + i.marginTop, left: si.left + i.marginLeft, width: n, height: r}; return D (d)} función W (e) {var t = e.nodeName; return'BODY '=== t ||' HTML '=== t?! 1:! (' Fixed '! == a (e,' position ')) || W (l (e))} función P (e, t, o, i) {var n = 4 <argumentos.longitud && void 0! == argumentos [4]? Argumentos [4]: ​​nulo, r = {arriba : 0, izquierda: 0}, p = n || u (e, t); if ('viewport' === i) r = k (p); else {var s; 'scrollParent' === i? (s = f (l (t)), 'BODY' === s.nodeName && (s = e.ownerDocument.documentElement)): 'ventana' === i? s = e.ownerDocument.documentElement: s = i ; var d = C (s, p); if ('HTML' === s.nodeName &&! W (p)) {var a = x (), m = a.height, h = a.width; r. arriba + = d.top-d.marginTop, r.bottom = m + d.top, r.left + = d.left-d.marginLeft, r.right = h + d.left} si no r = d} return r. izquierda + = o, r.top + = o, r.right- = o, r.bottom- = o, r} función B (e) {var t = e.width, o = e.height;return t * o} función H (e, t, o, i, n) {var r = 5 <argumentos.longitud && argumentos [5]! == void 0? argumentos [5]: 0; if (-1 === e.indexOf ('auto')) return e; var p = P (o, i, r, n, null), s = {top: {width: p.width, height: t.top-p.top} , derecha: {ancho: p.right-t.right, alto: p.height}, abajo: {ancho: p.width, alto: p.bottom-t.bottom}, izquierda: {ancho: t.left- p.left, height: p.height}}, d = Object.keys (s) .map (function (e) {return T ({key: e}, s [e], {area: B (s [e ])})}). sort (function (e, t) {return t.area-e.area}), a = d.filter (function (e) {var t = e.width, i = e.height ; return t> = o.clientWidth && i> = o.clientHeight}), l = 0 <a.length? a [0] .key: d [0] .key, f = e.split ('-') [1 ]; return l + (f? '-' + f: '')} función A (e, t, o, i) {var n = i || u (t, o); return C (o, n)} función I (e) {var t = getComputedStyle (e), o = parseFloat (t.marginTop) + parseFloat (t.marginBottom), i = parseFloat (t.marginLeft) + parseFloat (t.marginRight), n = {width: e.offsetWidth + i, height: e.offsetHeight + o}; return n} function F (e) {var t = {left: 'right', right: 'left', bottom: 'top', top: 'bottom'}; return e.replace (/ left | right | bottom | top / g, function (e) {return t [e]})} function M (e, t, o) { o = o.split ('-') [0]; var i = I (e), n = {ancho: i.width, height: i.height}, r = -1! == ['right', 'left']. indexOf (o), p = r? 'top': 'left', s = r? 'left': 'top', d = r? 'height': 'width', a = r? 'ancho': 'alto'; devuelve n [p] = t [p] + t [d] / 2-i [d] / 2, n [s] = o === s? t [s] -i [a]: t [F (s)], n} función R (e, t) {return Array.prototype.find? e.find (t): e.filter (t) [0]} función U (e , t, o) {if (Array.prototype.findIndex) return e.findIndex (function (e) {return e [t] === o}); var i = R (e, function (e) {return e [t] === o}); return e.indexOf (i)} función Y (e, t, o) {var i = void 0 === o? e: e.slice (0,U (e, 'nombre', o)); return i.forEach (function (e) {e ['function'] && console.warn ('`modifier.function` está en desuso, use` modifier.fn`!') ; var o = e ['función'] || e.fn; e. habilitado && d (o) && (t.offsets.popper = D (t.offsets.popper), t.offsets.reference = D (t.offsets .reference), t = o (t, e))}), t} function j () {if (! this.state.isDestroyed) {var e = {instance: this, styles: {}, arrowStyles: {} , atributos: {}, volteado:! 1, compensaciones: {}}; e.offsets.reference = A (this.state, this.popper, this.reference, this.options.positionFixed? window.document.documentElement: void 0), e.placement = H (this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.bo limitsElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options.positionFixed, e.offsets.popper = M (this.popper, e.offsets.referencia, e.placement), e.offsets.popper.position = this.options.positionFixed? 'fixed': 'absolute', e = Y (this.modifiers, e), this.state.isCreated? this.options. onUpdate (e) :( this.state.isCreated =! 0, this.options.onCreate (e))}} function q (e, t) {return e.some (function (e) {var o = e.name , i = e.enabled; return i && o === t})} función K (e) {for (var t = [! 1, 'ms', 'Webkit', 'Moz', 'O'], o = e.charAt (0) .toUpperCase () + e.slice (1), n ​​= 0; n <t.length-1; n ++) {var i = t [n], r = i? '' + i + o: e; if ('undefined'! = typeof document.body.style [r]) return r} return null} function V () {return this.state.isDestroyed =! 0, q (this.modifiers, 'applyStyle ') && (this.popper.removeAttribute (' ubicación-x '), this.popper.style.left =' ', this.popper.style.position =' ', this.popper.style.top =' ', this.popper.style [K ('transform ')] =' '), this.disableEventListeners (), this.options.removeOnDestroy && this.popper.parentNode.removeChild (this.popper), this} función z (e) {var t = e.ownerDocument; return t? t.defaultView: ventana} función G (e, t, o, i) {var n = 'BODY' === e.nodeName, r = n? e.ownerDocument.defaultView: e; r.addEventListener (t, o , {pasivo:! 0}), n || G (f (r.parentNode), t, o, i), i.push (r)} función _ (e, t, o, i) {o.updateBound = i, z (e) .addEventListener ('resize', o.updateBound, {passive:! 0}); var n = f (e); return G (n, 'scroll', o.updateBound, o.scrollParents ), o.scrollElement = n, o.eventsEnabled =! 0, o} function X () {this.state.eventsEnabled || (this.state = _ (this.reference, this.options, this.state, this. scheduleUpdate))} function J (e, t) {return z (e) .removeEventListener ('resize', t.updateBound), t.scrollParents.forEach (function (e) {e.removeEventListener ('scroll',t.updateBound)}), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled =! 1, t} function Q () {this.state.eventsEnabled && (cancelAnimationFrame (this. scheduleUpdate), this.state = J (this.reference, this.state))} función Z (e) {return ''! == e &&! isNaN (parseFloat (e)) && isFinite (e)} función $ (e, t) {Object.keys (t) .forEach (function (o) {var i = ''; - 1! == ['width', 'height', 'top', 'right', 'bottom', ' left ']. indexOf (o) && Z (t [o]) && (i =' px '), e.style [o] = t [o] + i})} función ee (e, t) {Object. keys (t) .forEach (function (o) {var i = t [o] ;! 1 === i? e.removeAttribute (o): e.setAttribute (o, t [o])})} función te (e) {return $ (e.instance.popper, e.styles), ee (e.instance.popper, e.attributes), e.arrowElement && Object.keys (e.arrowStyles) .length && $ (e.arrowElement, e .arrowStyles), e} función oe (e, t, o, i, n) {var r = A (n, t, e, o.positionFixed? window.document.documentElement: void 0), p = H (o. ubicación, r, t, e, o.modifiers.flip.bo limitsElement, o.modifiers.flip.padding); return t.setAttribute ('ubicación-x', p), $ (t, {position: o.positionFixed? 'fijo': 'absoluto'}), o} función ie (e, t) {var o = Math.floor, i = tx, n = ty, r = e.offsets.popper, p = R (e.instance .modifiers, function (e) {return'applyStyle '=== e.name}). gpuAcceleration; void 0! == p && console.warn (' ADVERTENCIA: la opción `gpuAcceleration` se movió al modificador` computeStyle` y no será compatible en futuras versiones de Popper.js! '); var s, d, a = void 0 === p? t.gpu Aceleración: p, l = m (e.instance.popper), f = N (l), h = {posición: r.posición}, c = {izquierda: o (r.izquierda), arriba: o (r.top), abajo: o (r.bottom), derecha: o (r.right)}, u = 'abajo' === i? 'arriba': 'abajo', g = 'right '=== n?' left ':' right ', b = K (' transform '); if (d =' bottom '== u? -f.height + c.bottom: c.top, s = 'right' == g? -f.width + c.right: c.left, a && b) h [b] = 'translate3d (' + s + 'px,' + d + 'px, 0)', h [u] = 0, h [g] = 0, h.willChange = 'transform'; else {var w = 'bottom' == u? -1: 1, y = 'right' == g? -1: 1; h [u] = d * w, h [g] = s * y, h.willChange = u + ',' + g} var E = {"ubicación-x": e.placement}; devuelve e.attributes = T ( {}, E, e.attributes), e.styles = T ({}, h, e.styles), e.arrowStyles = T ({}, e.offsets.arrow, e.arrowStyles), e} función ne (e, t, o) {var i = R (e, función (e) {var o = e.name; return o === t}), n = !! i && e.some (function (e) {return e.name === o && e.enabled && e.order <i.order}); if (! n) {var r = '`' + t + '`'; console.warn ('`' + o + '`' + ' El modificador es requerido por '+ r +'modificador para que funcione, asegúrese de incluirlo antes de '+ r +'! ')} return n} function re (e, t) {var o; if (! ne (e.instance.modifiers,' arrow ',' keepTogether ')) return e; var i = t.element; if (' string '== typeof i) {if (i = e.instance.popper.querySelector (i),! i) return e;} else if ( ! e.instance.popper.contains (i)) return console.warn ('ADVERTENCIA: ¡`arrow.element` debe ser hijo de su elemento popper!'), e; var n = e.placement.split ('-' ) [0], r = e.offsets, p = r.popper, s = r.reference, d = -1! == ['izquierda', 'derecha']. IndexOf (n), l = d? ' height ':' width ', f = d?' Top ':' Left ', m = f.toLowerCase (), h = d?' left ':' top ', c = d?' bottom ':' right ' , u = I (i) [l]; s [c] -u <p [m] && (e.offsets.popper [m] - = p [m] - (s [c] -u)), s [m] + u> p [c] && (e.offsets.popper [m] + = s [m] + up [c]), e.offsets.popper = D (e.offsets.popper); var g = s [m] + s [l] / 2-u / 2, b = a (e.instance.popper), w = parseFloat (b ['margin' + f], 10) , y = parseFloat (b ['border' + f + 'Width'], 10), E = ge.offsets.popper [m] -wy; return E = Math.max (Math.min (p [l] -u , E), 0), e.arrowElement = i, e.offsets.arrow = (o = {}, S (o, m, Math.round (E)), S (o, h, ''), o ), e} function pe (e) {if ('end' === e) return'start '; return'start' === e? 'end': e} var se = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom ',' bottom-start ',' left-end ',' left ',' left-start '], de = se.slice (3); función ae (e) {var t = 1 <argumentos.length && argumentos [1 ]! == void 0 && argumentos [1], o = de.indexOf (e), i = de.slice (o + 1) .concat (de.slice (0,o)); return t? i.reverse (): i} var le = {FLIP: 'flip', SENTIDO HORARIO: 'sentido horario', SENTIDO CONTRARIO: 'sentido antihorario'}; función fe (e, t) {if (q ( e.instance.modifiers, 'inner')) return e; if (e.flipped && e.placement === e.originalPlacement) return e; var o = P (e.instance.popper, e.instance.reference, t. padding, t.bo limitsElement, t.positionFixed? window.document.documentElement: void 0), i = e.placement.split ('-') [0], n = F (i), r = e.placement.split ('-') [1] || '', p = []; switch (t.behavior) {case le.FLIP: p = [i, n]; break; case le.CLOCKWISE: p = ae (i ); break; case le.COUNTERCLOCKWISE: p = ae (i,! 0); break; predeterminado: p = t.behavior;} return p.forEach (function (s, d) {if (i! == s | | p.length === d + 1) return e; i = e.placement.split ('-') [0], n = F (i); var a = e.offsets.popper, l = e. offsets.reference, f = Math.floor, m = 'izquierda' === i && f (a.derecha)> f (l.izquierda) || 'derecha' === i && f (a.izquierda) <f (l.derecha) || 'arriba' === i && f (a.bajo)> f (l.top) || 'abajo' = == i && f (a.top) <f (l.bottom), h = f (a.izquierda) <f (o.izquierda), c = f (a.derecha)> f (o.derecha), u = f (a.top) <f (o.top), g = f (a.bottom)> f (o.bottom), b = 'izquierda' === i && h || 'derecha' === i && c || 'top' === i && u || 'bottom' === i && g, w = -1! == ['top', 'bottom']. indexOf (i), y = !! t.flipVariations && (w && 'start '=== r && h || w &&' end '=== r && c ||! w &&' start '=== r && u ||! w &&' end '=== r && g); (m || b || y) && ( e.flipped =! 0, (m || b) && (i = p [d + 1]), y && (r = pe (r)), e.placement = i + (r? '-' + r: ' '), e.offsets.popper = T ({}, e.offsets.popper, M (e.instance.popper, e.offsets.reference, e.ubicación)), e = Y (e.instance.modifiers, e, 'flip'))}), e} function me (e) {var t = e.offsets, o = t.popper, i = t.reference , n = e.placement.split ('-') [0], r = Math.floor, p = -1! == ['top', 'bottom']. indexOf (n), s = p? ' right ':' bottom ', d = p?' left ':' top ', a = p?' width ':' height '; return o [s] <r (i [d]) && (e.offsets. popper [d] = r (i [d]) - o [a]), o [d]> r (i [s]) && (e.offsets.popper [d] = r (i [s])) , e} función he (e, t, o, i) {var n = Math.max, r = e.match (/ ((?: \ - | \ +)? \ d * \.? \ d *) (. *) /), p = + r [1], s = r [2]; if (! p) devuelve e; if (0 === s.indexOf ('%')) {var d; switch (s) {case '% p': d = o; break; case '%': case '% r': predeterminado: d = i;} var a = D (d); return a [t] / 100 * p} if ('vh' === s || 'vw' === s) {var l; return l = 'vh' === s? n (document.documentElement.clientHeight, window.innerHeight || 0 ): n (documento.documentElement.clientWidth, window.innerWidth || 0), l / 100 * p} return p} function ce (e, t, o, i) {var n = [0,0], r = -1! == [ 'derecha', 'izquierda']. indexOf (i), p = e.split (/ (\ + | \ -) ​​/). map (function (e) {return e.trim ()}), s = p .indexOf (R (p, function (e) {return-1! == e.search (/, | \ s /)})); p [s] && - 1 === p [s] .indexOf ( ',') && console.warn ('Las compensaciones separadas por espacios en blanco están en desuso, use una coma (,) en su lugar.'); var d = / \ s *, \ s * | \ s + /, a = - 1 === s? [P]: [p.slice (0, s) .concat ([p [s] .split (d) [0]]), [p [s] .split (d) [1 ]]. concat (p.slice (s + 1))]; return a = a.map (function (e, i) {var n = (1 === i?! r: r)? 'height': 'ancho', p =! 1; return e.reduce (function (e, t) {return '' === e [e.length-1] && - 1! == ['+', '-'] .indexOf (t)? (e [e.length-1] = t, p =! 0, e): p? (e [e.length-1] + = t, p =! 1, e): e .concat (t)}, []). map (function (e) {return he (e, n, t, o)})}), a.forEach (function (e, t) {e.forEach (function (o, i) {Z (o) && (n [t] + = o * ('-' === e [i-1]? - 1 : 1))})}), n} función ue (e, t) {var o, i = t.offset, n = e.placement, r = e.offsets, p = r.popper, s = r. referencia, d = n.split ('-') [0]; return o = Z (+ i)? [+ i, 0]: ce (i, p, s, d), 'left' === d ? (p.top + = o [0], p.left- = o [1]): 'right' === d? (p.top + = o [0], p.left + = o [1]): 'top' === d? (p.left + = o [0], p.top- = o [1]): 'bottom' === d && (p.left + = o [0], p.top + = o [1]), e.popper = p, e} función ge (e, t) {var o = e.positionFixed? window.document.documentElement: void 0, i = t.bo limitsElement || o || m ( e.instance.popper); e.instance.reference === i && (i = m (i)); var n = P (e.instance.popper, e.instance.reference, t.padding, i, o) ; t.boundary = n; var r = t.priority, p = e.offsets.popper, s = {primary: function (e) {var o = p [e]; return p [e] <n [e] &&! t.escapeWithReference && (o = Math.max (p [e], n [e])),S ({}, e, o)}, secundario: función (e) {var o = 'right' === e? 'Left': 'top', i = p [o]; return p [e]> n [e] &&! t.escapeWithReference && (i = Math.min (p [o], n [e] - ('right' === e? p.width: p.height))), S ({} , o, i)}}; return r.forEach (función (e) {var t = -1 === ['izquierda', 'arriba']. indexOf (e)? 'secundaria': 'primaria'; p = T ({}, p, s [t] (e))}), e.offsets.popper = p, e} función be (e) {var t = e.placement, o = t.split ('- ') [0], i = t.split (' - ') [1]; si (i) {var n = e.offsets, r = n. Referencia, p = n. Popper, s = -1! = = ['inferior', 'superior']. indexOf (o), d = s? 'left': 'top', a = s? 'width': 'height', l = {start: S ({}, d, r [d]), final: S ({}, d, r [d] + r [a] -p [a])}; e.offsets.popper = T ({}, p, l [i ])} return e} function we (e) {if (! ne (e.instance.modifiers, 'hide', 'preventOverflow')) return e; var t = e.offsets.reference, o = R (e.instancia.modificadores, función (e) {return'preventOverflow '=== e.name}). límites; if (t.bottom <o.top || t.left> o.right || t.top> o. bottom || t.right <o.left) {if (! 0 === e.hide) return e; e.hide =! 0, e.attributes ['x-fuera-de-límites'] = '' } else {if (! 1 === e.hide) return e; e.hide =! 1, e.attributes ['x-out-of-limits'] =! 1} return e} función ye (e) {var t = e.placement, o = t.split ('-') [0], i = e.offsets, n = i.popper, r = i.reference, p = -1! == ['left ',' right ']. indexOf (o), s = -1 === [' top ',' left ']. indexOf (o); return n [p?' left ':' top '] = r [ o] - (s? n [p? 'width': 'height']: 0), e.placement = F (t), e.offsets.popper = D (n), e} var Ee = {shift: {order: 100, enabled:! 0, fn: be}, offset: {order: 200, enabled:! 0, fn: ue, offset: 0}, preventOverflow: {order: 300, enabled:! 0, fn: ge, prioridad: ['izquierda', 'derecha', 'top ',' bottom '], padding: 5, limitsElement:' scrollParent '}, keepTogether: {order: 400, enabled:! 0, fn: me}, arrow: {order: 500, enabled:! 0, fn: re, element: '[x-arrow]'}, flip: {order: 600, enabled:! 0, fn: fe, behavior: 'flip', padding: 5, limitsElement: 'viewport'}, inner: {order : 700, habilitado:! 1, fn: ye}, ocultar: {orden: 800, habilitado:! 0, fn: we}, computeStyle: {orden: 850, habilitado:! 0, fn: ie, gpuAcceleration:! 0 , x: 'bottom', y: 'right'}, applyStyle: {order: 900, enabled:! 0, fn: te, onLoad: oe, gpuAcceleration: void 0}}, ve = {ubicación: 'bottom', positionFixed:! 1, eventsEnabled:! 0, removeOnDestroy:! 1, onCreate: function () {}, onUpdate: function () {}, modificadores: Ee}, xe = function () {function e (t, o) { var i = esto, n = 2 <argumentos.longitud && void 0! == argumentos [2]? argumentos [2]: {}; O (esto, e), this.scheduleUpdate = function () {return requestAnimationFrame (i.update)}, this.update = s (this.update.bind (this)), this.options = T ({}, e.Defaults, n), this.state = {isDestroyed:! 1, isCreated:! 1 , scrollParents: []}, this.reference = t && t.jquery? t [0]: t, this.popper = o && o.jquery? o [0]: o, this.options.modifiers = {}, Object.keys ( T ({}, e.Defaults.modifiers, n.modifiers)). ForCada (función (t) {i.options.modifiers [t] = T ({}, e.Defaults.modifiers [t] || {} , n.modificadores? n.modificadores [t]: {})}), this.modifiers = Object.keys (this.options.modifiers) .map (function (e) {return T ({name: e}, i .options.modifiers [e])}). sort (function (e, t) {return e.order-t.order}), this.modifiers.forEach (function (e) {e.enabled && d (e.onLoad) && e.onLoad (i.reference, i.popper, i.options, e, i.state)}), this.update (); var r = this.options.eventsEnabled; r && this.enableEventListeners (), this.state. eventsEnabled = r} return L (e, [{clave: 'actualizar', valor:function () {return j.call (this)}}, {key: 'destroy', value: function () {return V.call (this)}}, {key: 'enableEventListeners', value: function () { return X.call (this)}}, {clave: 'disableEventListeners', value: function () {return Q.call (this)}}]), e} (); xe.Utils = ('undefined' == typeof window? global: window) .PopperUtils, xe.placements = se, xe.Defaults = ve; export default xe;
// # sourceMappingURL = popper.min.js.map